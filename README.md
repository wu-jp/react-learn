# Context

> Context（上下文），表示做某些事的环境。
>

**Context上下文特点：**

1. 当某个组件创建了上下文后，上下文中的数据，会被所有后代组件共享
2. 如果某个组件依赖了上级组件的上下文，会导致该组件不再纯粹（外部数据仅来源于属性props）
3. 一般情况下，用于第三方组件（通用组件）

## 旧版API

**创建上下文：**

> 只有类组件才可以创建上下文
>
1. 给类组件书写静态属性`childContextTypes`，使该属性对上下文的数据进行`约束`
2. 添加实例方法`getChildContext`，`该方法返回的对象，即为上下文中的数据`，该数据`必须满足步骤一`的类型约束。该方法会在每次`render之后运行`。

**使用上下文数据：**

前提要求：如果要使用上下文中的数据，组件必须有一个`静态属性contextTypes`，该属性描述了需要获取的上下文中的数据类型

1. 可以在类组件的构造函数中，通过第二个参数，获取到上下文（不推荐：由于组件的构造函数只会执行一次，所有无法实时更新数据）
2. 可以从类组件的context属性中获取（推荐）
3. 函数组件中，可以通过第二个参数，获取上下文

**上下文的变化问题：**

上下文中的数据`子组件不可直接改变`，最终都是通过祖先组件通过状态（state、props）改变

给上下文中添加一个处理函数，可以用于后代组件调用该函数来更改上下文的数据

## 新版API

旧版API存在效率问题，并且容易导致滥用

**创建上下文**

上下文是一个独立于组件的对象，该对象通过`React.createContext(默认值)`创建

返回的是一个包含两个属性的对象

1. `Provider属性：生产者。一个组件`，该组件会创建一个上下文，该组件有一个value属性，通过该属性，可以为其数据赋值
    1. 同一个Provider，不要用到多个组件中，如果需要在其他组件中使用该数据，应该考虑将数据提升到更高的层次
2. `Consumer属性：使用者，一个组件。`该组件的字节点是一个函数（它的props.children需要传递一个函数）

**使用上下文：**

1. 在类组件中，直接使用this.context获取上下文数据
    1. 要求：必须拥有静态属性 contextType , 应赋值为创建的上下文对象
2. 在函数/类组件中，需要使用Consumer来获取上下文数据
    1. Consumer是一个组件
    2. 它的子节点，是一个函数（它的props.children需要传递一个函数）

**注意细节：**

如果，上下文提供者（Context.Provider）中的value属性发生变化(Object.is比较)，会导致该上下文提供的所有后代元素全部重新渲染，无论该子元素是否有优化（无论shouldComponentUpdate函数返回什么结果）